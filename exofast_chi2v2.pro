;+
; NAME:
;   EXOFAST_CHI2
;
; PURPOSE: 
;   Computes the chi2 for a transit and/or RV for a single planet
;
; CALLING SEQUENCE:
;    chi2 = exofast_chi2v2(pars)
;
; INPUTS:
;
;    PARS - An array of parameters that describes the model. There
;           should be one for each parameter in the structure where
;           fit==true. This array should be generated by str2pars.pro.
;
; OPTIONAL INPUTS:
; 
;    PSNAME      - If specified, this routine will generate
;                  postscript figure for each model generated with a
;                  base of PSNAME. 
;
; OPTIONAL OUTPUTS:
;    
;    DETERMINANT - The determinant of the Jacobian to weight the
;                  acceptance likelihood in order to impose
;                  non-uniform priors in the stepping parameters. This
;                  is equal to 1 (no transformation) unless MIST
;                  models are used. If MIST models are used,
;                  DETERMINANT is equal to d(EEP)/d(Age) to transform
;                  the uniform EEP prior into a uniform Age prior.
;    MODELRV     - The RV model given the parameters
;    MODELFLUX   - The Transit model given the parameters
;    DERIVED     - An array of derived parameters. Nothing is ever
;                  returned in DERIVED, but this keyword is required
;                  by EXOFAST_DEMC.
;
; RESULT:
;    The chi^2 of the model given the data and parameters.
;
; COMMON BLOCKS:
;   CHI2_BLOCK - See exofastv2.pro for definition
;
; MODIFICATION HISTORY
; 
;  2018/03 -- Create documentation -- Jason Eastman (CfA)
;-

function exofast_chi2v2, pars, determinant=determinant, $
                         modelrv=modelrv, modelflux=modelflux, psname=psname, $
                         derived=derived

COMMON chi2_block, ss
;; populate the structure with the new parameters
if n_elements(pars) ne 0 then pars2str, pars, ss

au = ss.constants.au/ss.constants.rsun

;; derive all required parameters 
;; (this may change depending on parameterization)
;derivepars, ss

;; initialize the determinant and chi^2
chi2 = 0.d0
determinant = 1d0

;; physical limb darkening (Kipping, 2013)
;; http://adsabs.harvard.edu/abs/2013MNRAS.435.2152K, eq 8
if (where(ss.planet.fittran))[0] ne -1 then begin
   bad = where(ss.band.u1.value + ss.band.u2.value gt 1d0 or $
               ss.band.u1.value lt 0d0 or $
               ss.band.u1.value + 2d0*ss.band.u2.value lt 0d0, nbad)
   if nbad gt 0 then begin
      if ss.debug then printandlog, strtrim(nbad,2) + ' limb darkening parameters are bad (' + strtrim(ss.band[bad[0]].u1.value,2) + ', ' + strtrim(ss.band[bad[0]].u2.value,2) + ')',ss.logname
      return, !values.d_infinity
   endif
endif

;; 0.1 < Period < 10^13 (~age of the universe)
bad = where(ss.planet.logp.value gt 13d0 or ss.planet.logp.value lt -1d0,nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'logP is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; tc-period/2 < tc < tc+period/2
ss.planet.period.value = 10^ss.planet.logp.value
bad = where(abs(ss.planet.tc.value - ss.planet.tc.prior) gt ss.planet.period.value/2d0,nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'tc is bad (' + strtrim(ss.planet[bad].tc.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; -max(period)/2 < ttv < max(period)/2
bad = where(abs(ss.transit.ttv.value) gt max(ss.planet.period.value)/2d0,nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'ttv is bad (' + strtrim(ss.transit[bad].ttv.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 0 <= cosi <= 1 (or -1 <= cosi <= 1 if i180 keyword set or astrometry fit)
bad = where(ss.planet.cosi.value gt 1 or (ss.planet.cosi.value lt 0 and ~ss.planet.i180) or (ss.planet.cosi.value lt -1),nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'cosi is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; older than the universe (too conservative?)
if ss.star.age.value gt 13.82d0 or ss.star.age.value lt 0d0 then begin
   if ss.debug then printandlog, strtrim(nbad,2) + ' age is bad (' + strtrim(bad,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; positive extinction
if ss.star.av.value lt 0 or ss.star.av.value gt 1d3 then begin
   if ss.debug then printandlog, 'extinction is bad (' + strtrim(ss.star.av.value,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; can't have more than +/-100% dilution
bad = where((ss.band.u1.fit or ss.band.u2.fit) and (ss.band.dilute.value le -1 or ss.band.dilute.value ge 1),nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'dilution is bad (' + strtrim(ss.band[bad].dilute.value,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; 0.9 AU to the size of the universe
if ss.star.distance.value lt 4d-6 or ss.star.distance.value gt 3d10 then begin
   if ss.debug then printandlog, 'distance is bad (' + strtrim(ss.star.distance.value,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; bound marginally detected planets to limit (infinite) parameter space at low logK
;; conservative lower limit of 1 Ceres in 1 year orbit around sun = 10 um/s
;; conservative upper limit corresponds to 500 solar masses (larger
;; than the largest known star)
bad = where((ss.planet.logk.value lt -5d0 or ss.planet.logk.value gt 5d0) and ss.planet.logk.fit, nbad)
if nbad gt 0 then begin
   if ss.debug  or ss.verbose then printandlog, 'logK is bad (' + strtrim(ss.planet[bad].logk.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; -c < gamma < c
bad = where(abs(ss.telescope.gamma.value) gt ss.constants.c/ss.constants.meter,nbad)
if nbad gt 0 then begin
   if ss.debug  or ss.verbose then printandlog, 'gamma is bad (' + strtrim(ss.telescope[bad].gamma.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

bad = where(abs(ss.telescope.jittervar.value) gt (ss.constants.c/ss.constants.meter)^2,nbad)
if nbad gt 0 then begin
   if ss.debug  or ss.verbose then printandlog, 'jittervar is bad (' + strtrim(ss.telescope[bad].jittervar.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

if abs(ss.star.slope.value) gt 1d5 then begin
   if ss.debug  or ss.verbose then printandlog, 'slope is bad (' + strtrim(ss.star.slope.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

if abs(ss.star.quad.value) gt 1d5 then begin
   if ss.debug  or ss.verbose then printandlog, 'quad is bad (' + strtrim(ss.star.quad.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 0.01 < SED error scaling < 100
if ss.star.errscale.value lt 1d-2 or ss.star.errscale.value gt 1d2 then begin
   if ss.debug or ss.verbose then printandlog, 'error scale is bad (' + strtrim(ss.star.errscale.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; -10 < [Fe/H] < 2 
if ss.star.feh.value lt -10d0 or ss.star.feh.value gt 2d0 then begin
   if ss.debug or ss.verbose then printandlog, 'teff is bad (' + strtrim(ss.star.teff.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 100 < Teff < 50000 
if ss.star.teff.value lt 100 or ss.star.teff.value gt 250000 then begin
   if ss.debug or ss.verbose then printandlog, 'teff is bad (' + strtrim(ss.star.teff.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 10^-6 < rstar < 2000
if ss.star.rstar.value lt 1d-6 or ss.star.rstar.value gt 2000d0 then begin
   if ss.debug or ss.verbose then printandlog, 'rstar is bad (' + strtrim(ss.star.rstar.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 10^-3 < mstar < 500
if ss.star.logmstar.value lt -3 or ss.star.logmstar.value gt 2.6989700d0 then begin
   if ss.debug or ss.verbose then printandlog, 'mstar is bad (' + strtrim(ss.star.mstar.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

if ss.nastrom gt 0 then begin
   ;; 0.01 < astrometric error scaling < 100
   bad = where(ss.astrom.astromscale.value lt 1d-2 or ss.astrom.astromscale.value  gt 1d2, nbad)
   if nbad gt 0 then begin
      if ss.debug or ss.verbose then printandlog, 'astrometry error scale is bad (' + strtrim(ss.astrom[bad].errscale.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif
   
   ;; 0 <= ra+raoffset <= 360
   bad = where(ss.star.ra.value + ss.astrom.raoffset.value lt 0 or ss.star.ra.value + ss.astrom.raoffset.value gt 360,nbad)
   if nbad gt 0 then begin
      if ss.debug or ss.verbose then printandlog, 'ra is bad (' + strtrim(ss.star.ra.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif

   ;; -90 <= dec+decoffset <= 90
   bad = where(abs(ss.star.dec.value + ss.astrom.decoffset.value) gt 90,nbad)
   if nbad gt 0 then begin
      if ss.debug or ss.verbose then printandlog, 'dec is bad (' + strtrim(ss.star.dec.value +ss.astrom[bad].decoffset.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif

   ;; -20000 <= pmra <= 20000 (2x barnard's star)
   if abs(ss.star.pmra.value) gt 2d4 then begin
      if ss.debug or ss.verbose then printandlog, 'pmra is bad (' + strtrim(ss.star.pmra.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif

   ;; -20000 <= pmdec <= 20000 (2x barnard's star)
   if abs(ss.star.pmdec.value) gt 2d4 then begin
      if ss.debug or ss.verbose then printandlog, 'pmdec is bad (' + strtrim(ss.star.pmdec.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif

   ;; -c <= rvabs <= c 
   if abs(ss.star.rvabs.value) gt ss.constants.c/ss.constants.meter then begin
      if ss.debug or ss.verbose then printandlog, 'pmdec is bad (' + strtrim(ss.star.pmdec.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif

endif

;; 0.01 < DT error scaling < 100
bad = where(ss.doptom.dtscale.value le 1d-2 or ss.doptom.dtscale.value gt 1d2, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'dtscale is bad (' + strtrim(ss.doptom[bad].dtscale.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; limit range of alpha abundance (not used yet)
;if ss.star.alpha.value lt -0.3d0 or ss.star.alpha.value gt 0.7d0 then begin
;   if ss.debug or ss.verbose then printandlog, 'alpha is bad (' + strtrim(ss.star.alpha.value,2) + ')', ss.logname
;   return, !values.d_infinity
;endif

;; derive the model parameters from the stepping parameters (return if
;; unphysical)
if step2pars(ss,verbose=ss.debug,logname=ss.logname) eq -1 then begin
   if ss.debug or ss.verbose then printandlog, 'stellar system is bad', ss.logname
   return, !values.d_infinity
endif

;; if angles are directly fit, repopulate the parameter array 
;; (to ensure they stay in range)
if (where(ss.planet.omega.fit))[0] ne -1 or $
   (where(ss.planet.bigomega.fit))[0] ne -1 or $
   (where(ss.planet.lambda.fit))[0] ne -1 then pars = str2pars(ss)

;; use the YY tracks to guide the stellar parameters
if ss.yy then begin
   if keyword_set(psname) then epsname = psname+'.yy.eps'
   yychi2 = massradius_yy3(ss.star.mstar.value, ss.star.feh.value, $
                           ss.star.age.value, ss.star.teff.value,$
                           yyrstar=yyrstar, debug=ss.debug, psname=epsname, $
                           sigmab=ss.constants.sigmab/ss.constants.lsun*ss.constants.rsun^2, $
                           gravitysun=ss.constants.gravitysun)
   if ~finite(yychi2) then begin
      if ss.debug then printandlog, 'star not on YY tracks', ss.logname
      return, !values.d_infinity
   endif

   yychi2 += ((ss.star.rstar.value - yyrstar)/(0.03*yyrstar))^2
   chi2 += yychi2
   if ss.verbose then printandlog, 'YY penalty = ' + strtrim(yychi2,2), ss.logname
endif

;; use the MIST tracks to guide the stellar parameters
if ss.mist then begin
   if keyword_set(psname) then epsname = psname+'.mist.eps'

   mistchi2 = massradius_mist(ss.star.eep.value, ss.star.mstar.value, ss.star.initfeh.value, $
                              ss.star.age.value, ss.star.teff.value,$
                              ss.star.rstar.value, ss.star.feh.value, debug=ss.debug, $
                              epsname=epsname, gravitysun=ss.constants.gravitysun, $
                              fitage=ss.star.age.fit, ageweight=ageweight, logname=ss.logname, verbose=ss.verbose)

   chi2 += mistchi2
   if ss.verbose then printandlog, 'MIST penalty = ' + strtrim(mistchi2,2), ss.logname
   if ~finite(chi2) then begin
      if ss.debug then printandlog, 'star not on MIST tracks', ss.logname
      return, !values.d_infinity
   endif
   determinant *= ageweight ;; correct uniform EEP prior to uniform Age prior

endif

;; use the Torres relation to guide the stellar parameters
if ss.torres then begin
   massradius_torres, ss.star.logg.value, ss.star.teff.value, ss.star.feh.value, mstar_prior, rstar_prior
   umstar = 0.027d0
   urstar = 0.014d0
   if mstar_prior lt 0.6d0 then printandlog, $
      'WARNING: Torres not applicable (mstar = ' + $
      strtrim(mstar_prior,2) + '); ignore at beginning. Otherwise, ' + $
      'use MIST, YY, or impose a prior on mstar/rstar',ss.logname
   ;; add "prior" penalty
   chi2 += (alog10(ss.star.mstar.value/mstar_prior)/umstar)^2
   chi2 += (alog10(ss.star.rstar.value/rstar_prior)/urstar)^2

   if ss.verbose then $
      printandlog, 'Torres penalty: ' + string((alog10(ss.star.mstar.value/mstar_prior)/umstar)^2, $
                                               (alog10(ss.star.rstar.value/rstar_prior)/urstar)^2,format='(f0.6,x,f0.6)'), ss.logname
endif

;; add prior penalties
priors = *(ss.priors)
for i=0, n_elements(priors[0,*])-1 do begin

   ;; if it's a detrending variable
   if priors[3,i] eq -1 then begin
      value = ss.(priors[0,i])[priors[1,i]].(priors[2,i]).value
      upperbound = ss.(priors[0,i])[priors[1,i]].(priors[2,i]).upperbound
      lowerbound =  ss.(priors[0,i])[priors[1,i]].(priors[2,i]).lowerbound 
      label =  ss.(priors[0,i])[priors[1,i]].(priors[2,i]).label + '_' + strtrim(priors[1,i],2)
      prior =  ss.(priors[0,i])[priors[1,i]].(priors[2,i]).prior
      priorwidth = ss.(priors[0,i])[priors[1,i]].(priors[2,i]).priorwidth
      unit = strupcase(ss.(priors[0,i])[priors[1,i]].(priors[2,i]).unit)
   endif else begin
      ;; otherwise
      value = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].value
      upperbound = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].upperbound
      lowerbound = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].lowerbound 
      label =  (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].label + '_' + strtrim(priors[1,i],2)
      prior = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].prior
      priorwidth = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].priorwidth
      unit = strupcase((*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].unit)
   endelse 

   ;; apply the bounds
   if value gt upperbound or value lt lowerbound then begin
      if ss.debug then $
         printandlog, label + '( ' + strtrim(value,2) + ') is out of user-defined bounds (' +$
                      strtrim(lowerbound,2) + ',' + strtrim(upperbound,2) + ')',ss.logname
      return, !values.d_infinity
   endif

   ;; if it's an angular parameter, make sure the prior accounts for the periodicity
   if unit eq 'RADIANS' then begin
      if (value - prior) gt !dpi then prior += 2d0*!dpi $
      else if (value - prior) lt -!dpi then prior -= 2d0*!dpi
   endif else if unit eq 'DEGREES' then begin
      if (value - prior) gt 180d0 then prior += 360d0 $
      else if (value - prior) lt -180d0 then prior -= 360d0
   endif

   ;; apply the Gaussian prior
   chi2 += ((value - prior)/priorwidth)^2

   ;; output debugging info if requested
   if ss.verbose then begin
      str = string(label,((value - prior)/priorwidth)^2, format='(a," penalty = ",f0.6)')
      printandlog, str, logname
   endif

endfor

;; Apply the Mass-Radius relation 
;; Chen & Kipping, 2017 (http://adsabs.harvard.edu/abs/2017ApJ...834...17C)
;; this introduces a near perfect correlation between K and p, which
;; AMOEBA finds challenging to work with (but is handled naturally by DEMC)
;; does it? Or was that a bug that has been fixed?
for j=0, ss.nplanets-1 do begin
   if ss.planet[j].chen then begin

      ;; negative radii are allowed to assess the significance of the
      ;; transit depth. That breaks these relations, so exclude them here
      if ss.planet[j].rpearth.value le 0d0 then begin
         if ss.debug then printandlog, 'rpearth is bad', ss.logname
         return, !values.d_infinity
      endif

      rp = massradius_chen(ss.planet[j].mpearth.value > 1d-10,rperr=rperr)

      ;; add a chi2 penalty for deviation from the mass-radius relation
      ;; if the radius is well-constrained (by transit depth), it
      ;; becomes an implicit constraint on mass. If the mass is well
      ;; constrained (by RV), it is an explicit constraint on
      ;; radius
      chi2 += ((rp - ss.planet[j].rpearth.value)/rperr)^2
      
      if ss.verbose then printandlog, 'chen penalty = ' + strtrim(((rp - ss.planet[j].rpearth.value)/rperr)^2,2),logname
   endif
endfor

;; fit the SED with MIST BC tables
;t0 = systime(/seconds)
if file_test(ss.star.mistsedfile) then begin
   if keyword_set(psname) then epsname = psname+'.sed.eps'
   sedchi2 = mistsed(ss.star.teff.value, ss.star.logg.value,ss.star.feh.value, ss.star.av.value, ss.star.distance.value, ss.star.lstar.value, ss.star.errscale.value, ss.star.mistsedfile, debug=ss.debug, psname=epsname)

   chi2 += sedchi2
   if ss.verbose then printandlog, 'SED penalty = ' + strtrim(sedchi2,2), ss.logname

endif
;print, 'MIST SED: ' + strtrim(systime(/seconds)-t0,2)

;; fit the SED (Keivan's)
;t0 = systime(/seconds)
if file_test(ss.star.fluxfile) then begin
   if keyword_set(psname) then epsname = psname+'.sed.eps'
   sedchi2 = exofast_sed(ss.star.fluxfile, ss.star.teff.value, $
                         ss.star.rstar.value,$
                         ss.star.av.value, ss.star.distance.value, $
                         logg=ss.star.logg.value,met=ss.star.feh.value,$
                         alpha=ss.star.alpha.value,verbose=ss.verbose, $
                         f0=f, fp0=fp, ep0=ep, psname=epsname, $
                         pc=ss.constants.pc, rsun=ss.constants.rsun, $
                         logname=logname, debug=ss.debug)

   if ~finite(sedchi2) then begin
      if ss.debug then printandlog, 'sed is bad', ss.logname
      return, !values.d_infinity
   endif

   sedchi2 = exofast_like(f-fp,0d0,ss.star.errscale.value*ep,/chi2)
   if ~finite(sedchi2) then begin
      if ss.debug then printandlog, 'sed is bad', ss.logname
      return, !values.d_infinity
   endif
   chi2 += sedchi2
   if ss.verbose then printandlog, 'SED penalty = ' + strtrim(sedchi2,2), ss.logname
endif
;print, 'Keivan SED: ' + strtrim(systime(/seconds)-t0,2)

;; this should never be encountered, just a waste of time
;for i=0, ss.nplanets-1 do begin
;   if ss.planet[i].ecosw.fit and ss.planet[i].esinw.fit then begin
;      determinant *= ss.planet[i].e.value
;   endif
;endfor


if ss.star.slope.fit then begin
   allmindate = !values.d_infinity
   allmaxdate = -!values.d_infinity
   for i=0, ss.ntel-1 do begin
      rv = *(ss.telescope[i].rvptrs)
      mindate = min(rv.bjd,max=maxdate)
      if mindate lt allmindate then allmindate = mindate
      if maxdate gt allmaxdate then allmaxdate = maxdate
   endfor
   t0 = (allmindate+allmaxdate)/2d0
endif else t0 = 0d0

;; RV model (non-interacting planets)
for j=0, ss.ntel-1 do begin

   rv = *(ss.telescope[j].rvptrs)

   if (where(rv.err^2 + ss.telescope[j].jittervar.value le 0d0))[0] ne -1 then return, !values.d_infinity

   modelrv = dblarr(n_elements(rv.rv))
   for i=0, ss.nplanets-1 do begin

      if ss.planet[i].fitrv then begin      
         ;; rvbjd = rv.bjd ;; usually sufficient (See Eastman et al., 2013)

         ;; time in target barycentric frame (expensive)
         rvbjd = bjd2target(rv.bjd, inclination=ss.planet[i].i.value, $
                            a=ss.planet[i].a.value, tp=ss.planet[i].tp.value, $
                            period=ss.planet[i].period.value, e=ss.planet[i].e.value,$
                            omega=ss.planet[i].omega.value,/primary,$
                            c=ss.constants.c/ss.constants.au*ss.constants.day)
         
         ;; calculate the RV model
         if ss.planet[i].rossiter then $
            u1 = linld(ss.star.logg.value,ss.star.teff.value,ss.star.feh.value,'V') $
         else u1 = 0d0
         modelrv += exofast_rv(rvbjd,ss.planet[i].tp.value,ss.planet[i].period.value,$
                               0d0,ss.planet[i].K.value,$
                               ss.planet[i].e.value,ss.planet[i].omega.value,$
                               slope=0d0, $
                               rossiter=ss.planet[i].rossiter, i=ss.planet[i].i.value,a=ss.planet[i].ar.value,$
                               p=abs(ss.planet[i].p.value),vsini=ss.star.vsini.value,$
                               lambda=ss.planet[i].lambda.value,$
                               u1=u1,deltarv=deltarv)

      endif

   endfor
   ;; add instrumental offset, slope, and quadratic term
   modelrv += ss.telescope[j].gamma.value + ss.star.slope.value*(rv.bjd-t0) + ss.star.quad.value*(rv.bjd-t0)^2

   (*ss.telescope[j].rvptrs).residuals = rv.rv - modelrv
   
   if keyword_set(psname) then begin
      base = file_dirname(psname) + path_sep() + file_basename(psname,'.model')
      exofast_forprint, rv.bjd, rv.rv - modelrv, rv.err, format='(f0.8,x,f0.6,x,f0.6)', textout=base + '.residuals.telescope_' + strtrim(j,2) + '.txt', /nocomment,/silent
      exofast_forprint, rv.bjd, modelrv, format='(f0.8,x,f0.6)', textout=base + '.model.telescope_' + strtrim(j,2) + '.txt', /nocomment,/silent
   endif

   rvchi2 = exofast_like((*ss.telescope[j].rvptrs).residuals,ss.telescope[j].jittervar.value,rv.err,/chi2)
   if ~finite(rvchi2) then stop
   chi2 += rvchi2
   if ss.verbose then printandlog, ss.telescope[j].label + ' RV penalty = ' + strtrim(rvchi2,2),ss.logname
endfor

;; if at least one RV planet is fit, plot it
if (where(ss.planet.fitrv))[0] ne -1 then begin
   if keyword_set(psname) then begin
      plotrv, ss, psname=psname + '.rv.ps'
   endif else if ss.debug then begin
      plotrv, ss
   endif
endif

;; Doppler Tomography Model
for i=0, ss.ndt-1 do begin
   if keyword_set(psname) then epsname = psname + '.dt_' + strtrim(i,2) + '.eps'
   dtchi2 = dopptom_chi2(*(ss.doptom[i].dtptrs),$
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].tc.value, $
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].period.value, $
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].e.value,$
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].omega.value, $
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].cosi.value, $
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].p.value,$
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].ar.value,$
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].lambda.value, $
                         ss.star.logg.value, ss.star.teff.value, ss.star.feh.value,$
                         ss.star.vsini.value/1d3,ss.star.vline.value/1d3,$
                         ss.doptom[i].dtscale.value, debug=ss.debug,/like,psname=epsname)

   if 0 then begin
   stop
   npoints = 1000
   vsini = 17000d0 + dindgen(npoints)/(npoints-1)*4000d0
   vline = 500d0 + dindgen(npoints)/(npoints-1)*10000d0
;   vsini = 19000d0 + dindgen(npoints)/(npoints-1)*2000d0
   dtchi2 = dblarr(npoints)
   for ii=0, npoints-1 do dtchi2[ii] = dopptom_chi2(*(ss.doptom[i].dtptrs),ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].tc.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].period.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].e.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].omega.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].cosi.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].p.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].ar.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].lambda.value,ss.star.logg.value, ss.star.teff.value, ss.star.feh.value,vsini[ii]/1d3,ss.star.vline.value/1d3,ss.doptom[i].dtscale.value, debug=ss.debug,/like,psname=epsname)   
   plot, vsini, dtchi2

   dtchi22 = dblarr(npoints)
   for ii=0, npoints-1 do dtchi22[ii] = dopptom_chi2(*(ss.doptom[i].dtptrs),ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].tc.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].period.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].e.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].omega.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].cosi.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].p.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].ar.value,ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].lambda.value,ss.star.logg.value, ss.star.teff.value, ss.star.feh.value,ss.star.vsini.value/1d3,vline[ii]/1d3,ss.doptom[i].dtscale.value, debug=ss.debug,/like,psname=epsname)
   plot, vline, dtchi22
   endif
   


   if ~finite(dtchi2) then return, !values.d_infinity
   chi2 += dtchi2
   if ss.verbose then printandlog, ss.doptom[i].label + ' DT penalty = ' + strtrim(dtchi2,2),ss.logname
endfor

;; Transit model
for j=0, ss.ntran-1 do begin

   transit = *(ss.transit[j].transitptrs)

   if (where(transit.err^2 + ss.transit[j].variance.value le 0d0))[0] ne -1 then return, !values.d_infinity

   band = ss.band[ss.transit[j].bandndx]

   ;; quadratic limb darkening
   if ss.claret then begin
      ldcoeffs = quadld(ss.star.logg.value, ss.star.teff.value, ss.star.feh.value, band.name)
      u1claret = ldcoeffs[0]
      u2claret = ldcoeffs[1]
      if ~finite(u1claret) or ~finite(u2claret) then return, !values.d_infinity
      u1err = 0.05d0 
      u2err = 0.05d0
      chi2 += ((band.u1.value-u1claret)/u1err)^2
      chi2 += ((band.u2.value-u2claret)/u2err)^2
      if ss.verbose then printandlog, band.label + ' u1 penalty = ' + strtrim(((band.u1.value-u1claret)/u1err)^2,2),ss.logname
      if ss.verbose then printandlog, band.label + ' u2 penalty = ' + strtrim(((band.u2.value-u2claret)/u2err)^2,2),ss.logname
   endif

   ;; Kepler Long candence data; create several model points and average   
   ninterp = ss.transit[j].ninterp
   npoints = n_elements(transit.bjd)

   if ninterp gt 1 then begin
      transitbjd = transit.bjd#(dblarr(ninterp)+1d0) + $
                   ((dindgen(ninterp)/ninterp-(ninterp-1d0)/(2d0*ninterp))/$
                    1440d0*ss.transit[j].exptime)##(dblarr(npoints)+1d0)
      modelflux = dblarr(npoints,ninterp) + 1d0
   endif else begin
      transitbjd = transit.bjd
      modelflux = dblarr(npoints) + 1d0
   endelse

;   ;; get the motion of the star due to all planets
;   junk = exofast_getb2(transitbjd,inc=ss.planet.i.value,a=ss.planet.ar.value,$
;                        tperiastron=ss.planet.tp.value,$
;                        period=ss.planet.period.value,$
;                        e=ss.planet.e.value,omega=ss.planet.omega.value,$
;                        q=ss.star.mstar.value/ss.planet.mpsun.value,$
;                        x1=x1,y1=y1,z1=z1)

   for i=0, ss.nplanets-1 do begin
      if ss.planet[i].fittran then begin

         modelflux += (exofast_tran(transitbjd, $
                                    ss.planet[i].i.value + ss.transit[j].tiv.value, $
                                    ss.planet[i].ar.value, $
                                    ss.planet[i].tp.value + ss.transit[j].ttv.value, $
                                    ss.planet[i].period.value, $
                                    ss.planet[i].e.value,$
                                    ss.planet[i].omega.value,$
                                    ss.planet[i].p.value + ss.transit[j].tdeltav.value,$
                                    band.u1.value, $
                                    band.u2.value, $
                                    1d0, $
                                    q=ss.star.mstar.value/ss.planet[i].mpsun.value, $
                                    thermal=band.thermal.value, $
                                    reflect=band.reflect.value, $
                                    dilute=band.dilute.value,$
                                    tc=ss.planet[i].tc.value,$
                                    rstar=ss.star.rstar.value/AU,$
                                    ;x1=x1,y1=y1,z1=z1,$
                                    au=au,$
                                    c=ss.constants.c/ss.constants.au*ss.constants.day) - 1d0)

      endif
   endfor

   
   if ss.transit[j].rejectflatmodel then begin
      minmodel = min(modelflux,max=maxmodel)
      if minmodel eq maxmodel then begin
         if ss.verbose then printandlog, ss.transit[j].label + ' transit model has no signal! Rejecting this step a priori, but this may artificially enhance the significance of the signal', ss.logname
         return, !values.d_infinity
      endif
   endif


   ;; now integrate the model points (before detrending)
   ;; Riemann integration beats trapezoidal and simpsons wins when
   ;; sampling like above
   if ninterp gt 1 then modelflux = total(modelflux,2)/ninterp

   ;; Trapezoidal integration not as good
   ;;if ninterp gt 1 then modelflux = (total(modelflux,2) - modelflux[*,0]/2d0 - modelflux[*,-1]/2d0)/(ninterp-1d0)

   ;; Simpson integration (about 2x worse than trap because it
   ;; requires sampling at the midpoint, effectively halving our resolution)
   ;if ninterp gt 1 then modelflux = (4d0*total(modelflux,2) - 3d0*modelflux[*,0] - 3d0*modelflux[*,-1])/(4d0*ninterp - 6d0)

   ;; detrending
   modelflux += total(transit.detrendadd*(replicate(1d0,n_elements(transit.bjd))##transit.detrendaddpars.value),1) 
   modelflux *= (ss.transit[j].f0.value + $
                 total(transit.detrendmult*(replicate(1d0,n_elements(transit.bjd))##transit.detrendmultpars.value),1))

   ;; fit Andrew Vanderburg's keplerspline to the residuals to detrend the lightcurve
   if ss.transit[j].fitspline then begin
      if transit.breakpts[0] eq -1 then $
         norm = keplerspline(transit.bjd, transit.flux-modelflux+1d0, ndays=ss.transit[j].splinespace) $
      else norm = keplerspline(transit.bjd, transit.flux-modelflux+1d0, breakp=transit.breakpts, ndays=ss.transit[j].splinespace)
      modelflux *= norm
   endif

   ;; chi^2
   transitchi2 = exofast_like(transit.flux - modelflux,ss.transit[j].variance.value,transit.err,/chi2)

   (*ss.transit[j].transitptrs).residuals = transit.flux - modelflux
   (*ss.transit[j].transitptrs).model = modelflux

   if keyword_set(psname) then begin
      base = file_dirname(psname) + path_sep() + file_basename(psname,'.model')
      exofast_forprint, transit.bjd, transit.flux - modelflux, transit.err, format='(f0.8,x,f0.6,x,f0.6)', textout=base + '.residuals.transit_' + strtrim(j,2) + '.txt', /nocomment,/silent
      exofast_forprint, transit.bjd, modelflux, format='(f0.8,x,f0.6)', textout=base + '.model.transit_' + strtrim(j,2) + '.txt', /nocomment,/silent
   endif

   if ~finite(transitchi2) then stop

   chi2 += transitchi2
   if ss.verbose then printandlog, ss.transit[j].label + ' transit penalty: ' + strtrim(transitchi2,2) + ' ' + strtrim(ss.transit[j].variance.value,2),ss.logname

endfor

;; plot the transit model and data 
;; if a transit is fit for at least one planet
if ((where(ss.planet.fittran))[0] ne -1) then begin
   if keyword_set(psname) then begin
      plottran, ss, psname=psname + '.transit.ps'
   endif else if ss.debug then begin
      plottran, ss
   endif
endif

;; if TTVs are allowed, add a chi2 penalty to the period and t0 from
;; the fit to a linear ephemeris
;; this imposes the constraint of the linear ephemeris while allowing TTVs
junk = where(ss.fittran, nfittran)
if ss.ttvs and nfittran eq 1 then begin
   ;; an nplanets x ntransits array of model transit times
   time = replicate(1,ss.nplanets)#ss.transit.ttv.value + $
          ss.planet.tc.value#replicate(1,ss.ntran) + $
          ss.planet.period.value#replicate(1,ss.ntran)*$
          ss.transit.epoch

   ;; add a chi2 penalty for the deviation of the ephemeris to the
   ;; linear fit of the transit times for each planet
   for i=0L, ss.nplanets-1L do begin

      good = where(finite(time[i,*]),ngood) ;; why wouldn't that be finite??
      if ngood lt 2 then continue
;      if ngood lt 2 then stop ;continue

      coeffs = poly_fit((ss.transit.epoch)[i,good],time[i,good],1, sigma=sigma, yfit=yfit)
      sigma = (sigma > 1d-18)

      chi2 += ((coeffs[0]-ss.planet[i].tc.value)/sigma[0])^2
      chi2 += ((coeffs[1]-ss.planet[i].period.value)/sigma[1])^2

      if ss.verbose then begin
         printandlog, 'Tc penalty ' + strtrim(((coeffs[0]-ss.planet[i].tc.value)/sigma[0])^2,2),ss.logname
         printandlog, 'Period penalty ' + strtrim(((coeffs[1]-ss.planet[i].period.value)/sigma[1])^2,2),ss.logname
      endif

      if ss.debug or keyword_set(psname) then begin
         if keyword_set(psname) then begin
            ;; astrobetter.com tip on making pretty IDL plots
            mydevice=!d.name
            set_plot, 'PS'
            aspect_ratio=1.5
            xsize=10.5
            ysize=xsize/aspect_ratio
            !p.font=0
            device, filename=psname + '.ttv.' + strtrim(i,2) + '.eps', /color, bits=24,/encapsulated
            device, xsize=xsize, ysize=ysize
            LOADCT, 39,/silent
            colors = [0,254,159,95,223,31,207,111,191,47]
            charsizelegend = 0.09
            xlegend = 0.1
            ylegend = 0.90
            charsize = 0.5
         endif else begin
            device,window_state=win_state
            if win_state[10+i] eq 1 then wset, 10+i $
            else window, 10+i, retain=2
            colors= ['ffffff'x,'0000ff'x,'00ff00'x,'ff0000'x,'0080ff'x,$
                     '800080'x,'00ffff'x,'ffff00'x,'80d000'x,'660000'x]
            charsizelegend = 0.03
            xlegend = 0.90
            ylegend = 0.95
            charsize = 1
         endelse
         ncolors = n_elements(colors)
         syms = [0,3,8,5,0,3,8,5]
         fill = [1,1,1,1,0,0,0,0]
         nsyms = n_elements(syms)
         
         telescopes = strarr(ss.ntran)
         for j=0L, ss.ntran-1L do telescopes[j] = (strsplit(ss.transit[j].label,' UT ',/regex,/extract))[0]
         sorted = sort(telescopes)
         tnames = telescopes[sorted[uniq(telescopes[sorted])]]

         xmin = min((ss.transit.epoch)[i,good],max=xmax)
         ymin = min((time[i,good]-yfit)*86400d0,max=ymax)
         plot, [0],[0],psym=3, xtitle='!3Epoch', ytitle='!3O-C (seconds)',xrange=[xmin,xmax],yrange=[ymin,ymax]
         for j=0, n_elements(tnames)-1 do begin
            observed = where(telescopes eq tnames[j])
            if observed[0] ne -1 then begin
               plotsym, syms[j mod nsyms], color=colors[j mod ncolors],fill=fill[j mod nsyms]
               oplot, ((ss.transit.epoch)[i,good])[observed],(time[i,good[observed]]-yfit[observed])*86400d0,psym=8
               xsize = (!x.crange[1] - !x.crange[0])
               ysize = (!y.crange[1] - !y.crange[0])

               ;; only need a legend if we have more than one telescope
               if n_elements(tnames) gt 1 then begin
                  xyouts, !x.crange[0] + xlegend*xsize,!y.crange[0]+(ylegend - j*charsizelegend)*ysize, $
                          tnames[j],color=colors[j mod ncolors],charsize=charsize
                  oplot, [!x.crange[0]+xlegend*xsize-xsize/20],$
                         [!y.crange[0]+(ylegend - (j-0.25)*charsizelegend)*ysize],psym=8
               endif
            endif
         endfor
         oplot, [-9d9,9d9],[0d0,0d0],linestyle=2

         if keyword_set(psname) then begin
            !p.font=-1
            !p.multi=0
            device, /close
            device, encapsulated=0
            set_plot, mydevice
         endif

      endif
   endfor
endif

;; astrometric model
nastromplots = 4
for i=0L, ss.nastrom-1 do begin

   astrom = *(ss.astrom[i].astromptrs)

   ;; get the motion of the star due to all planets relative to its barycenter 
   ;; in units of rstar
   junk = exofast_getb2(astrom.bjdtdb,inc=ss.planet.i.value,a=ss.planet.ar.value,$
                        tperiastron=ss.planet.tp.value,$
                        period=ss.planet.period.value,$
                        e=ss.planet.e.value,omega=ss.planet.omega.value,$
                        lonascnode=ss.planet.bigomega.value,$
                        q=ss.star.mstar.value/ss.planet.mpsun.value,$
                        x1=x1,y1=y1,z1=z1, x0=x0,y0=y0,z0=z0)

   ;; Photocenter in AU about the system barycenter
   if ss.band[ss.astrom[i].bandndx].dilute.value eq 0d0 then begin
      ;; If not diluted, it simplifies to the stellar position
      starpos = transpose([[x1],[y1],[z1]])*ss.star.rstar.value*ss.constants.rsun/ss.constants.au 
   endif else begin
      ;; Otherwise, must account for blending
      ;; See https://arxiv.org/pdf/1807.09880.pdf, Appendix B
      phottobary = ss.band[ss.astrom[i].bandndx].phottobary.value

      ;; ****check sign returned by exofast_getb2!!!****
      starpos = -[x0[0,*],y0[0,*],z0[0,*]]*ss.star.rstar.value*ss.constants.rsun/ss.constants.au/phottobary

      ;; this breaks for multiple, bright planets (triple stars?)!!!
      if ss.verbose and ss.nplanets gt 1 then printandlog, 'WARNING: multiple bright companions not supported!', ss.logname
   endelse

   if ~keyword_set(astrom.userhopa) then begin
      ;; get the stellar coordinates (angles) relative to ICRS
      radec = exofast_astrom(astrom.bjdtdb, ss.star.ra.value+ss.astrom[i].raoffset.value,$
                             ss.star.dec.value+ss.astrom[i].decoffset.value, $
                             ss.star.pmra.value, ss.star.pmdec.value, $
                             px=ss.star.parallax.value, $
                             rv=ss.star.rvabs.value, $
                             epoch=astrom.epoch,obspos=astrom.obspos, $
                             au=ss.constants.au/ss.constants.meter, starpos=starpos)
      astromchi2 = exofast_like(radec-astrom.radec,0d0,ss.astrom[i].astromscale.value*astrom.err,/chi2)
   endif else begin

      ;; scale factor to convert units of rstar to mas
      ascale = ss.star.rstar.value*ss.constants.rsun/ss.constants.pc/ss.star.distance.value*3600d3*180/!dpi


      rhopa = transpose([[sqrt(x1^2 + y1^2)*ascale],[atan(y1,x1)]])
      astromchi2 = exofast_like(rhopa-astrom.rhopa,0d0,ss.astrom[i].astromscale.value*astrom.rhopaerr,/chi2)
   endelse

   if ss.verbose then printandlog, ss.astrom[i].label + ' astrometry penalty: ' + strtrim(astromchi2,2),ss.logname
   if ~finite(astromchi2) then begin
      print
      print, 'ERROR, NaN chi^2 from astrometry!'
      stop
      return, !values.d_infinity
   endif

   chi2 += astromchi2

   if ss.debug or keyword_set(psname) then begin
      if keyword_set(psname) then begin
         ;; astrobetter.com tip on making pretty IDL plots
         mydevice=!d.name
         set_plot, 'PS'
         aspect_ratio=1.5
         xsize=10.5
         ysize=xsize/aspect_ratio
         !p.font=0
         device, filename=psname + '.astrometry.' + strtrim(i,2) + '.ps', /color, bits=24
         device, xsize=xsize, ysize=ysize
         LOADCT, 39,/silent
         colors = [0,254,159,95,223,31,207,111,191,47]
         charsizelegend = 0.09
         xlegend = 0.1
         ylegend = 0.90
         charsize = 0.5
      endif else begin
         device,window_state=win_state
         colors= ['ffffff'x,'0000ff'x,'00ff00'x,'ff0000'x,'0080ff'x,$
                  '800080'x,'00ffff'x,'ffff00'x,'80d000'x,'660000'x]
         charsizelegend = 0.03
         xlegend = 0.90
         ylegend = 0.95
         charsize = 1
      endelse
      ncolors = n_elements(colors)
      syms = [0,3,8,5,0,3,8,5]
      fill = [1,1,1,1,0,0,0,0]
      nsyms = n_elements(syms)

      ;; get the motion of the star due to all planets relative to its barycenter 
      ;; in units of rstar
      junk = exofast_getb2(astrom.prettytime,inc=ss.planet.i.value,a=ss.planet.ar.value,$
                           tperiastron=ss.planet.tp.value,$
                           period=ss.planet.period.value,$
                           e=ss.planet.e.value,omega=ss.planet.omega.value,$
                           lonascnode=ss.planet.bigomega.value,$
                           q=ss.star.mstar.value/ss.planet.mpsun.value,$
                           x1=prettyx1,y1=prettyy1,z1=prettyz1, x0=prettyx0,y0=prettyy0,z0=prettyz0)        
      
      if ~keyword_set(astrom.userhopa) then begin
         radecnocompanion = exofast_astrom(astrom.bjdtdb, ss.star.ra.value+ss.astrom[i].raoffset.value,$
                                           ss.star.dec.value+ss.astrom[i].decoffset.value, $
                                           ss.star.pmra.value, ss.star.pmdec.value, $
                                           px=ss.star.parallax.value, $
                                           rv=ss.star.rvabs.value, $
                                           epoch=astrom.epoch,obspos=astrom.obspos, $
                                           au=ss.constants.au/ss.constants.meter, starpos=0d0)
         
         ;; Photocenter in AU about the system barycenter
         if ss.band[ss.astrom[i].bandndx].dilute.value eq 0d0 then begin
            ;; If not diluted, it simplifies to the stellar position
            prettystarpos = transpose([[prettyx1],[prettyy1],[prettyz1]])*ss.star.rstar.value*ss.constants.rsun/ss.constants.au 
         endif else begin
            ;; Otherwise, must account for blending
            ;; See https://arxiv.org/pdf/1807.09880.pdf, Appendix B
            ;; ****check sign returned by exofast_getb2!!!****
            prettystarpos = -[prettyx0[0,*],prettyy0[0,*],prettyz0[0,*]]*ss.star.rstar.value*ss.constants.rsun/ss.constants.au/phottobary        
            ;; this breaks for multiple, bright planets (triple stars?)!!!
            if ss.verbose and ss.nplanets gt 1 then printandlog, 'WARNING: multiple bright companions not supported!', ss.logname
         endelse
         
         prettyradec = exofast_astrom(astrom.prettytime, ss.star.ra.value+ss.astrom[i].raoffset.value,$
                                      ss.star.dec.value+ss.astrom[i].decoffset.value, $
                                      ss.star.pmra.value, ss.star.pmdec.value, $
                                      px=ss.star.parallax.value, $
                                      rv=ss.star.rvabs.value, $
                                      epoch=astrom.epoch,obspos=astrom.prettyobspos, $
                                      au=ss.constants.au/ss.constants.meter, starpos=prettystarpos)
         
         prettyradecnocompanion = exofast_astrom(astrom.prettytime, ss.star.ra.value+ss.astrom[i].raoffset.value,$
                                                 ss.star.dec.value+ss.astrom[i].decoffset.value, $
                                                 ss.star.pmra.value, ss.star.pmdec.value, $
                                                 px=ss.star.parallax.value, $
                                                 rv=ss.star.rvabs.value, $
                                                 epoch=astrom.epoch,obspos=astrom.prettyobspos, $
                                                 au=ss.constants.au/ss.constants.meter, starpos=0d0)
         
         
         xmin = min(astrom.bjdtdb-astrom.epoch,max=xmax)
         ymin = min([[radec[0,*],astrom.radec[0,*]]-ss.star.ra.value,[radec[1,*],astrom.radec[1,*]]-ss.star.dec.value],max=ymax)
         
         if ~keyword_set(psname) then begin
            if win_state[i*nastromplots] eq 1 then wset, i*nastromplots $
            else window, i*nastromplots, retain=2
         endif
         plot, astrom.prettytime-astrom.epoch, (prettyradec[0,*]-ss.star.ra.value)*3600d6, xtitle='Time - ' + strtrim(astrom.epoch,2) + ' (days)', xrange=[xmin,xmax], yrange=[ymin,ymax]*3600d6,ytitle=exofast_textoidl('Motion (\muas)')
         oplot, astrom.prettytime-astrom.epoch, (prettyradec[1,*]-ss.star.dec.value)*3600d6,color=colors[1]
         oplot, astrom.bjdtdb-astrom.epoch, (astrom.radec[0,*]-ss.star.ra.value)*3600d6, psym=1
         oplot, astrom.bjdtdb-astrom.epoch, (astrom.radec[1,*]-ss.star.dec.value)*3600d6,psym=1,color=colors[1]
         
         if ~keyword_set(psname) then begin
            if win_state[i*nastromplots+1] eq 1 then wset, i*nastromplots+1 $
            else window, i*nastromplots+1, retain=2
         endif
         plot, (prettyradec[0,*]-ss.star.ra.value)*3600d6,(prettyradec[1,*]-ss.star.dec.value)*3600d6, xtitle=exofast_textoidl('\alpha - \alpha_0 (\muas)'), ytitle=exofast_textoidl('\delta-\delta_0 (\muas)'),/iso, xrange=[ymin,ymax]*3600d6,yrange=[ymin,ymax]*3600d6
         oplot, (astrom.radec[0,*]-ss.star.ra.value)*3600d6,(astrom.radec[1,*]-ss.star.dec.value)*3600d6, psym=1
         
         if ~keyword_set(psname) then begin
            if win_state[i*nastromplots+2] eq 1 then wset, i*nastromplots+2 $
            else window, i*nastromplots+2, retain=2
         endif
         ymin = min([radec[0,*]-radecnocompanion[0,*],astrom.radec[0,*]-radecnocompanion[0,*],radec[1,*]-radecnocompanion[1,*],astrom.radec[1,*]-radecnocompanion[1,*]],max=ymax)
         plot, (prettyradec[0,*]-prettyradecnocompanion[0,*])*3600d6, (prettyradec[1,*]-prettyradecnocompanion[1,*])*3600d6, xtitle=exofast_textoidl('\alpha - \alpha_0 (\muas)'), ytitle=exofast_textoidl('\delta-\delta_0 (\muas)'),/iso, yrange=[ymin,ymax]*3600d6,xrange=[ymax,ymin]*3600d6
         oplot, (astrom.radec[0,*]-radecnocompanion[0,*])*3600d6, (astrom.radec[1,*]-radecnocompanion[1,*])*3600d6, psym=1
         
         if ~keyword_set(psname) then begin
            if win_state[i*nastromplots+3] eq 1 then wset, i*nastromplots+3 $
            else window, i*nastromplots+3, retain=2
         endif
         plot, astrom.prettytime-astrom.epoch, (prettyradec[0,*]-prettyradecnocompanion[0,*])*3600d6, xtitle='Time - ' + strtrim(astrom.epoch,2) + ' (days)', ytitle=exofast_textoidl('Residuals (\muas)'), yrange=[ymin,ymax]*3600d6,xrange=[xmin,xmax]
         oplot, astrom.bjdtdb-astrom.epoch, (astrom.radec[0,*]-radecnocompanion[0,*])*3600d6, psym=1
         oplot, astrom.prettytime-astrom.epoch, (prettyradec[1,*]-prettyradecnocompanion[1,*])*3600d6, color=colors[1]
         oplot, astrom.bjdtdb-astrom.epoch, (astrom.radec[1,*]-radecnocompanion[1,*])*3600d6, color=colors[1], psym=1
      endif else begin
         ascale*=5
         xmin=max(prettyy1*ascale,min=xmax)
         ymin=min(prettyx1*ascale,max=ymax)
         plot, prettyy1*ascale, prettyx1*ascale, xtitle='East (mas)',ytitle='North (mas)',/iso, xrange=[xmin,xmax],yrange=[ymin,ymax]
         oplot, [0],[0], psym=2
         eastdata = astrom.rhopa[0,*]*cos(astrom.rhopa[1,*])
         northdata = astrom.rhopa[0,*]*sin(astrom.rhopa[1,*])
         oplot, eastdata, northdata, psym=1
stop
      endelse


      if keyword_set(psname) then begin
         !p.font=-1
         !p.multi=0
         device, /close
         device, encapsulated=0
         set_plot, mydevice
      endif
   endif

endfor

;; print all the parameters and the chi^2
if ss.debug or ss.verbose then printandlog, string(pars, chi2, format='(' + strtrim(n_elements(pars)+1,2) + '(f0.8,x))'),ss.logname

;; if this stop is triggered, you've found a bug!!
if ~finite(chi2) then begin
   printandlog, "You've found a bug! Usually this is triggered by runaway parameters that are not constrained by the data or priors. Re-running with /DEBUG and /VERBOSE flags may help track it down, and please email jason.eastman@cfa.harvard.edu to fix the underlying problem.", ss.logname
   stop
endif

return, chi2

end

